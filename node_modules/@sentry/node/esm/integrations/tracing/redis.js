import { _optionalChain } from '@sentry/utils';
import { IORedisInstrumentation } from '@opentelemetry/instrumentation-ioredis';
import { defineIntegration, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_CACHE_KEY, SEMANTIC_ATTRIBUTE_CACHE_HIT, spanToJSON } from '@sentry/core';
import { generateInstrumentOnce } from '../../otel/instrument.js';

function keyHasPrefix(key, prefixes) {
  return prefixes.some(prefix => key.startsWith(prefix));
}

/** Currently, caching only supports 'get' and 'set' commands. More commands will be added (setex, mget, del, expire) */
function shouldConsiderForCache(
  redisCommand,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  key,
  prefixes,
) {
  return (redisCommand === 'get' || redisCommand === 'set') && typeof key === 'string' && keyHasPrefix(key, prefixes);
}

function calculateCacheItemSize(response) {
  try {
    if (Buffer.isBuffer(response)) return response.byteLength;
    else if (typeof response === 'string') return response.length;
    else if (typeof response === 'number') return response.toString().length;
    else if (response === null || response === undefined) return 0;
    return JSON.stringify(response).length;
  } catch (e) {
    return undefined;
  }
}

const INTEGRATION_NAME = 'Redis';

let _redisOptions = {};

const instrumentRedis = generateInstrumentOnce(INTEGRATION_NAME, () => {
  return new IORedisInstrumentation({
    responseHook: (span, redisCommand, cmdArgs, response) => {
      const key = cmdArgs[0];

      span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.redis');

      if (!_optionalChain([_redisOptions, 'optionalAccess', _ => _.cachePrefixes]) || !shouldConsiderForCache(redisCommand, key, _redisOptions.cachePrefixes)) {
        // not relevant for cache
        return;
      }

      // otel/ioredis seems to be using the old standard, as there was a change to those params: https://github.com/open-telemetry/opentelemetry-specification/issues/3199
      // We are using params based on the docs: https://opentelemetry.io/docs/specs/semconv/attributes-registry/network/
      const networkPeerAddress = _optionalChain([spanToJSON, 'call', _2 => _2(span), 'access', _3 => _3.data, 'optionalAccess', _4 => _4['net.peer.name']]);
      const networkPeerPort = _optionalChain([spanToJSON, 'call', _5 => _5(span), 'access', _6 => _6.data, 'optionalAccess', _7 => _7['net.peer.port']]);
      if (networkPeerPort && networkPeerAddress) {
        span.setAttributes({ 'network.peer.address': networkPeerAddress, 'network.peer.port': networkPeerPort });
      }

      const cacheItemSize = calculateCacheItemSize(response);
      if (cacheItemSize) span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, cacheItemSize);

      if (typeof key === 'string') {
        switch (redisCommand) {
          case 'get':
            span.setAttributes({
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'cache.get_item', // todo: will be changed to cache.get
              [SEMANTIC_ATTRIBUTE_CACHE_KEY]: key,
            });
            if (cacheItemSize !== undefined) span.setAttribute(SEMANTIC_ATTRIBUTE_CACHE_HIT, cacheItemSize > 0);
            break;
          case 'set':
            span.setAttributes({
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'cache.put',
              [SEMANTIC_ATTRIBUTE_CACHE_KEY]: key,
            });
            break;
        }
      }
    },
  });
});

const _redisIntegration = ((options = {}) => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      _redisOptions = options;
      instrumentRedis();

      // todo: implement them gradually
      // new LegacyRedisInstrumentation({}),
      // new RedisInstrumentation({}),
    },
  };
}) ;

/**
 * Redis integration for "ioredis"
 *
 * Capture tracing data for redis and ioredis.
 */
const redisIntegration = defineIntegration(_redisIntegration);

export { instrumentRedis, redisIntegration };
//# sourceMappingURL=redis.js.map
